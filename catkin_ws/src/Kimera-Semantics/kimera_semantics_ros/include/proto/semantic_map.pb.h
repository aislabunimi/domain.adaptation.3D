// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: semantic_map.proto

#ifndef PROTOBUF_INCLUDED_semantic_5fmap_2eproto
#define PROTOBUF_INCLUDED_semantic_5fmap_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_semantic_5fmap_2eproto 

namespace protobuf_semantic_5fmap_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_semantic_5fmap_2eproto
namespace kimera {
class SemanticMapProto;
class SemanticMapProtoDefaultTypeInternal;
extern SemanticMapProtoDefaultTypeInternal _SemanticMapProto_default_instance_;
class SemanticMapProto_SemanticBlockProto;
class SemanticMapProto_SemanticBlockProtoDefaultTypeInternal;
extern SemanticMapProto_SemanticBlockProtoDefaultTypeInternal _SemanticMapProto_SemanticBlockProto_default_instance_;
class SemanticMapProto_SemanticBlockProto_OriginProto;
class SemanticMapProto_SemanticBlockProto_OriginProtoDefaultTypeInternal;
extern SemanticMapProto_SemanticBlockProto_OriginProtoDefaultTypeInternal _SemanticMapProto_SemanticBlockProto_OriginProto_default_instance_;
class SemanticMapProto_SemanticBlockProto_SemanticVoxelProto;
class SemanticMapProto_SemanticBlockProto_SemanticVoxelProtoDefaultTypeInternal;
extern SemanticMapProto_SemanticBlockProto_SemanticVoxelProtoDefaultTypeInternal _SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_default_instance_;
class SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto;
class SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProtoDefaultTypeInternal;
extern SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProtoDefaultTypeInternal _SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto_default_instance_;
}  // namespace kimera
namespace google {
namespace protobuf {
template<> ::kimera::SemanticMapProto* Arena::CreateMaybeMessage<::kimera::SemanticMapProto>(Arena*);
template<> ::kimera::SemanticMapProto_SemanticBlockProto* Arena::CreateMaybeMessage<::kimera::SemanticMapProto_SemanticBlockProto>(Arena*);
template<> ::kimera::SemanticMapProto_SemanticBlockProto_OriginProto* Arena::CreateMaybeMessage<::kimera::SemanticMapProto_SemanticBlockProto_OriginProto>(Arena*);
template<> ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto* Arena::CreateMaybeMessage<::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto>(Arena*);
template<> ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* Arena::CreateMaybeMessage<::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace kimera {

// ===================================================================

class SemanticMapProto_SemanticBlockProto_OriginProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kimera.SemanticMapProto.SemanticBlockProto.OriginProto) */ {
 public:
  SemanticMapProto_SemanticBlockProto_OriginProto();
  virtual ~SemanticMapProto_SemanticBlockProto_OriginProto();

  SemanticMapProto_SemanticBlockProto_OriginProto(const SemanticMapProto_SemanticBlockProto_OriginProto& from);

  inline SemanticMapProto_SemanticBlockProto_OriginProto& operator=(const SemanticMapProto_SemanticBlockProto_OriginProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SemanticMapProto_SemanticBlockProto_OriginProto(SemanticMapProto_SemanticBlockProto_OriginProto&& from) noexcept
    : SemanticMapProto_SemanticBlockProto_OriginProto() {
    *this = ::std::move(from);
  }

  inline SemanticMapProto_SemanticBlockProto_OriginProto& operator=(SemanticMapProto_SemanticBlockProto_OriginProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SemanticMapProto_SemanticBlockProto_OriginProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SemanticMapProto_SemanticBlockProto_OriginProto* internal_default_instance() {
    return reinterpret_cast<const SemanticMapProto_SemanticBlockProto_OriginProto*>(
               &_SemanticMapProto_SemanticBlockProto_OriginProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SemanticMapProto_SemanticBlockProto_OriginProto* other);
  friend void swap(SemanticMapProto_SemanticBlockProto_OriginProto& a, SemanticMapProto_SemanticBlockProto_OriginProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SemanticMapProto_SemanticBlockProto_OriginProto* New() const final {
    return CreateMaybeMessage<SemanticMapProto_SemanticBlockProto_OriginProto>(NULL);
  }

  SemanticMapProto_SemanticBlockProto_OriginProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SemanticMapProto_SemanticBlockProto_OriginProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SemanticMapProto_SemanticBlockProto_OriginProto& from);
  void MergeFrom(const SemanticMapProto_SemanticBlockProto_OriginProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SemanticMapProto_SemanticBlockProto_OriginProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:kimera.SemanticMapProto.SemanticBlockProto.OriginProto)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::protobuf_semantic_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.ColorProto) */ {
 public:
  SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto();
  virtual ~SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto();

  SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto(const SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto& from);

  inline SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto& operator=(const SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto(SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto&& from) noexcept
    : SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto() {
    *this = ::std::move(from);
  }

  inline SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto& operator=(SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* internal_default_instance() {
    return reinterpret_cast<const SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto*>(
               &_SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* other);
  friend void swap(SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto& a, SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* New() const final {
    return CreateMaybeMessage<SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto>(NULL);
  }

  SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto& from);
  void MergeFrom(const SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 r = 1;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 1;
  ::google::protobuf::int32 r() const;
  void set_r(::google::protobuf::int32 value);

  // optional int32 g = 2;
  bool has_g() const;
  void clear_g();
  static const int kGFieldNumber = 2;
  ::google::protobuf::int32 g() const;
  void set_g(::google::protobuf::int32 value);

  // optional int32 b = 3;
  bool has_b() const;
  void clear_b();
  static const int kBFieldNumber = 3;
  ::google::protobuf::int32 b() const;
  void set_b(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.ColorProto)
 private:
  void set_has_r();
  void clear_has_r();
  void set_has_g();
  void clear_has_g();
  void set_has_b();
  void clear_has_b();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 r_;
  ::google::protobuf::int32 g_;
  ::google::protobuf::int32 b_;
  friend struct ::protobuf_semantic_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SemanticMapProto_SemanticBlockProto_SemanticVoxelProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto) */ {
 public:
  SemanticMapProto_SemanticBlockProto_SemanticVoxelProto();
  virtual ~SemanticMapProto_SemanticBlockProto_SemanticVoxelProto();

  SemanticMapProto_SemanticBlockProto_SemanticVoxelProto(const SemanticMapProto_SemanticBlockProto_SemanticVoxelProto& from);

  inline SemanticMapProto_SemanticBlockProto_SemanticVoxelProto& operator=(const SemanticMapProto_SemanticBlockProto_SemanticVoxelProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SemanticMapProto_SemanticBlockProto_SemanticVoxelProto(SemanticMapProto_SemanticBlockProto_SemanticVoxelProto&& from) noexcept
    : SemanticMapProto_SemanticBlockProto_SemanticVoxelProto() {
    *this = ::std::move(from);
  }

  inline SemanticMapProto_SemanticBlockProto_SemanticVoxelProto& operator=(SemanticMapProto_SemanticBlockProto_SemanticVoxelProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SemanticMapProto_SemanticBlockProto_SemanticVoxelProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SemanticMapProto_SemanticBlockProto_SemanticVoxelProto* internal_default_instance() {
    return reinterpret_cast<const SemanticMapProto_SemanticBlockProto_SemanticVoxelProto*>(
               &_SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SemanticMapProto_SemanticBlockProto_SemanticVoxelProto* other);
  friend void swap(SemanticMapProto_SemanticBlockProto_SemanticVoxelProto& a, SemanticMapProto_SemanticBlockProto_SemanticVoxelProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SemanticMapProto_SemanticBlockProto_SemanticVoxelProto* New() const final {
    return CreateMaybeMessage<SemanticMapProto_SemanticBlockProto_SemanticVoxelProto>(NULL);
  }

  SemanticMapProto_SemanticBlockProto_SemanticVoxelProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SemanticMapProto_SemanticBlockProto_SemanticVoxelProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SemanticMapProto_SemanticBlockProto_SemanticVoxelProto& from);
  void MergeFrom(const SemanticMapProto_SemanticBlockProto_SemanticVoxelProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SemanticMapProto_SemanticBlockProto_SemanticVoxelProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto ColorProto;

  // accessors -------------------------------------------------------

  // repeated float semantic_labels = 2;
  int semantic_labels_size() const;
  void clear_semantic_labels();
  static const int kSemanticLabelsFieldNumber = 2;
  float semantic_labels(int index) const;
  void set_semantic_labels(int index, float value);
  void add_semantic_labels(float value);
  const ::google::protobuf::RepeatedField< float >&
      semantic_labels() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_semantic_labels();

  // optional .kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.ColorProto color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  private:
  const ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto& _internal_color() const;
  public:
  const ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto& color() const;
  ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* release_color();
  ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* mutable_color();
  void set_allocated_color(::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* color);

  // optional int32 linear_index = 3;
  bool has_linear_index() const;
  void clear_linear_index();
  static const int kLinearIndexFieldNumber = 3;
  ::google::protobuf::int32 linear_index() const;
  void set_linear_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto)
 private:
  void set_has_color();
  void clear_has_color();
  void set_has_linear_index();
  void clear_has_linear_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< float > semantic_labels_;
  ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* color_;
  ::google::protobuf::int32 linear_index_;
  friend struct ::protobuf_semantic_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SemanticMapProto_SemanticBlockProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kimera.SemanticMapProto.SemanticBlockProto) */ {
 public:
  SemanticMapProto_SemanticBlockProto();
  virtual ~SemanticMapProto_SemanticBlockProto();

  SemanticMapProto_SemanticBlockProto(const SemanticMapProto_SemanticBlockProto& from);

  inline SemanticMapProto_SemanticBlockProto& operator=(const SemanticMapProto_SemanticBlockProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SemanticMapProto_SemanticBlockProto(SemanticMapProto_SemanticBlockProto&& from) noexcept
    : SemanticMapProto_SemanticBlockProto() {
    *this = ::std::move(from);
  }

  inline SemanticMapProto_SemanticBlockProto& operator=(SemanticMapProto_SemanticBlockProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SemanticMapProto_SemanticBlockProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SemanticMapProto_SemanticBlockProto* internal_default_instance() {
    return reinterpret_cast<const SemanticMapProto_SemanticBlockProto*>(
               &_SemanticMapProto_SemanticBlockProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SemanticMapProto_SemanticBlockProto* other);
  friend void swap(SemanticMapProto_SemanticBlockProto& a, SemanticMapProto_SemanticBlockProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SemanticMapProto_SemanticBlockProto* New() const final {
    return CreateMaybeMessage<SemanticMapProto_SemanticBlockProto>(NULL);
  }

  SemanticMapProto_SemanticBlockProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SemanticMapProto_SemanticBlockProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SemanticMapProto_SemanticBlockProto& from);
  void MergeFrom(const SemanticMapProto_SemanticBlockProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SemanticMapProto_SemanticBlockProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SemanticMapProto_SemanticBlockProto_OriginProto OriginProto;
  typedef SemanticMapProto_SemanticBlockProto_SemanticVoxelProto SemanticVoxelProto;

  // accessors -------------------------------------------------------

  // repeated .kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto semantic_voxels = 4;
  int semantic_voxels_size() const;
  void clear_semantic_voxels();
  static const int kSemanticVoxelsFieldNumber = 4;
  ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto* mutable_semantic_voxels(int index);
  ::google::protobuf::RepeatedPtrField< ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto >*
      mutable_semantic_voxels();
  const ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto& semantic_voxels(int index) const;
  ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto* add_semantic_voxels();
  const ::google::protobuf::RepeatedPtrField< ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto >&
      semantic_voxels() const;

  // optional .kimera.SemanticMapProto.SemanticBlockProto.OriginProto origin = 3;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 3;
  private:
  const ::kimera::SemanticMapProto_SemanticBlockProto_OriginProto& _internal_origin() const;
  public:
  const ::kimera::SemanticMapProto_SemanticBlockProto_OriginProto& origin() const;
  ::kimera::SemanticMapProto_SemanticBlockProto_OriginProto* release_origin();
  ::kimera::SemanticMapProto_SemanticBlockProto_OriginProto* mutable_origin();
  void set_allocated_origin(::kimera::SemanticMapProto_SemanticBlockProto_OriginProto* origin);

  // optional double voxel_size = 2;
  bool has_voxel_size() const;
  void clear_voxel_size();
  static const int kVoxelSizeFieldNumber = 2;
  double voxel_size() const;
  void set_voxel_size(double value);

  // optional int32 voxels_per_side = 1;
  bool has_voxels_per_side() const;
  void clear_voxels_per_side();
  static const int kVoxelsPerSideFieldNumber = 1;
  ::google::protobuf::int32 voxels_per_side() const;
  void set_voxels_per_side(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kimera.SemanticMapProto.SemanticBlockProto)
 private:
  void set_has_voxels_per_side();
  void clear_has_voxels_per_side();
  void set_has_voxel_size();
  void clear_has_voxel_size();
  void set_has_origin();
  void clear_has_origin();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto > semantic_voxels_;
  ::kimera::SemanticMapProto_SemanticBlockProto_OriginProto* origin_;
  double voxel_size_;
  ::google::protobuf::int32 voxels_per_side_;
  friend struct ::protobuf_semantic_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SemanticMapProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kimera.SemanticMapProto) */ {
 public:
  SemanticMapProto();
  virtual ~SemanticMapProto();

  SemanticMapProto(const SemanticMapProto& from);

  inline SemanticMapProto& operator=(const SemanticMapProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SemanticMapProto(SemanticMapProto&& from) noexcept
    : SemanticMapProto() {
    *this = ::std::move(from);
  }

  inline SemanticMapProto& operator=(SemanticMapProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SemanticMapProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SemanticMapProto* internal_default_instance() {
    return reinterpret_cast<const SemanticMapProto*>(
               &_SemanticMapProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SemanticMapProto* other);
  friend void swap(SemanticMapProto& a, SemanticMapProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SemanticMapProto* New() const final {
    return CreateMaybeMessage<SemanticMapProto>(NULL);
  }

  SemanticMapProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SemanticMapProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SemanticMapProto& from);
  void MergeFrom(const SemanticMapProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SemanticMapProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SemanticMapProto_SemanticBlockProto SemanticBlockProto;

  // accessors -------------------------------------------------------

  // repeated .kimera.SemanticMapProto.SemanticBlockProto semantic_blocks = 1;
  int semantic_blocks_size() const;
  void clear_semantic_blocks();
  static const int kSemanticBlocksFieldNumber = 1;
  ::kimera::SemanticMapProto_SemanticBlockProto* mutable_semantic_blocks(int index);
  ::google::protobuf::RepeatedPtrField< ::kimera::SemanticMapProto_SemanticBlockProto >*
      mutable_semantic_blocks();
  const ::kimera::SemanticMapProto_SemanticBlockProto& semantic_blocks(int index) const;
  ::kimera::SemanticMapProto_SemanticBlockProto* add_semantic_blocks();
  const ::google::protobuf::RepeatedPtrField< ::kimera::SemanticMapProto_SemanticBlockProto >&
      semantic_blocks() const;

  // @@protoc_insertion_point(class_scope:kimera.SemanticMapProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::kimera::SemanticMapProto_SemanticBlockProto > semantic_blocks_;
  friend struct ::protobuf_semantic_5fmap_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SemanticMapProto_SemanticBlockProto_OriginProto

// optional double x = 1;
inline bool SemanticMapProto_SemanticBlockProto_OriginProto::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SemanticMapProto_SemanticBlockProto_OriginProto::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SemanticMapProto_SemanticBlockProto_OriginProto::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SemanticMapProto_SemanticBlockProto_OriginProto::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double SemanticMapProto_SemanticBlockProto_OriginProto::x() const {
  // @@protoc_insertion_point(field_get:kimera.SemanticMapProto.SemanticBlockProto.OriginProto.x)
  return x_;
}
inline void SemanticMapProto_SemanticBlockProto_OriginProto::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:kimera.SemanticMapProto.SemanticBlockProto.OriginProto.x)
}

// optional double y = 2;
inline bool SemanticMapProto_SemanticBlockProto_OriginProto::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SemanticMapProto_SemanticBlockProto_OriginProto::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SemanticMapProto_SemanticBlockProto_OriginProto::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SemanticMapProto_SemanticBlockProto_OriginProto::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double SemanticMapProto_SemanticBlockProto_OriginProto::y() const {
  // @@protoc_insertion_point(field_get:kimera.SemanticMapProto.SemanticBlockProto.OriginProto.y)
  return y_;
}
inline void SemanticMapProto_SemanticBlockProto_OriginProto::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:kimera.SemanticMapProto.SemanticBlockProto.OriginProto.y)
}

// optional double z = 3;
inline bool SemanticMapProto_SemanticBlockProto_OriginProto::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SemanticMapProto_SemanticBlockProto_OriginProto::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SemanticMapProto_SemanticBlockProto_OriginProto::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SemanticMapProto_SemanticBlockProto_OriginProto::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double SemanticMapProto_SemanticBlockProto_OriginProto::z() const {
  // @@protoc_insertion_point(field_get:kimera.SemanticMapProto.SemanticBlockProto.OriginProto.z)
  return z_;
}
inline void SemanticMapProto_SemanticBlockProto_OriginProto::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:kimera.SemanticMapProto.SemanticBlockProto.OriginProto.z)
}

// -------------------------------------------------------------------

// SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto

// optional int32 r = 1;
inline bool SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::set_has_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::clear_has_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline ::google::protobuf::int32 SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::r() const {
  // @@protoc_insertion_point(field_get:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.ColorProto.r)
  return r_;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::set_r(::google::protobuf::int32 value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.ColorProto.r)
}

// optional int32 g = 2;
inline bool SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::has_g() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::set_has_g() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::clear_has_g() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::clear_g() {
  g_ = 0;
  clear_has_g();
}
inline ::google::protobuf::int32 SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::g() const {
  // @@protoc_insertion_point(field_get:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.ColorProto.g)
  return g_;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::set_g(::google::protobuf::int32 value) {
  set_has_g();
  g_ = value;
  // @@protoc_insertion_point(field_set:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.ColorProto.g)
}

// optional int32 b = 3;
inline bool SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::has_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::set_has_b() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::clear_has_b() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline ::google::protobuf::int32 SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::b() const {
  // @@protoc_insertion_point(field_get:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.ColorProto.b)
  return b_;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto::set_b(::google::protobuf::int32 value) {
  set_has_b();
  b_ = value;
  // @@protoc_insertion_point(field_set:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.ColorProto.b)
}

// -------------------------------------------------------------------

// SemanticMapProto_SemanticBlockProto_SemanticVoxelProto

// optional .kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.ColorProto color = 1;
inline bool SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::clear_color() {
  if (color_ != NULL) color_->Clear();
  clear_has_color();
}
inline const ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto& SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::_internal_color() const {
  return *color_;
}
inline const ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto& SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::color() const {
  const ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* p = color_;
  // @@protoc_insertion_point(field_get:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.color)
  return p != NULL ? *p : *reinterpret_cast<const ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto*>(
      &::kimera::_SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto_default_instance_);
}
inline ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::release_color() {
  // @@protoc_insertion_point(field_release:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.color)
  clear_has_color();
  ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::mutable_color() {
  set_has_color();
  if (color_ == NULL) {
    auto* p = CreateMaybeMessage<::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto>(GetArenaNoVirtual());
    color_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.color)
  return color_;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::set_allocated_color(::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto_ColorProto* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    set_has_color();
  } else {
    clear_has_color();
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.color)
}

// repeated float semantic_labels = 2;
inline int SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::semantic_labels_size() const {
  return semantic_labels_.size();
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::clear_semantic_labels() {
  semantic_labels_.Clear();
}
inline float SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::semantic_labels(int index) const {
  // @@protoc_insertion_point(field_get:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.semantic_labels)
  return semantic_labels_.Get(index);
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::set_semantic_labels(int index, float value) {
  semantic_labels_.Set(index, value);
  // @@protoc_insertion_point(field_set:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.semantic_labels)
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::add_semantic_labels(float value) {
  semantic_labels_.Add(value);
  // @@protoc_insertion_point(field_add:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.semantic_labels)
}
inline const ::google::protobuf::RepeatedField< float >&
SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::semantic_labels() const {
  // @@protoc_insertion_point(field_list:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.semantic_labels)
  return semantic_labels_;
}
inline ::google::protobuf::RepeatedField< float >*
SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::mutable_semantic_labels() {
  // @@protoc_insertion_point(field_mutable_list:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.semantic_labels)
  return &semantic_labels_;
}

// optional int32 linear_index = 3;
inline bool SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::has_linear_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::set_has_linear_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::clear_has_linear_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::clear_linear_index() {
  linear_index_ = 0;
  clear_has_linear_index();
}
inline ::google::protobuf::int32 SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::linear_index() const {
  // @@protoc_insertion_point(field_get:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.linear_index)
  return linear_index_;
}
inline void SemanticMapProto_SemanticBlockProto_SemanticVoxelProto::set_linear_index(::google::protobuf::int32 value) {
  set_has_linear_index();
  linear_index_ = value;
  // @@protoc_insertion_point(field_set:kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto.linear_index)
}

// -------------------------------------------------------------------

// SemanticMapProto_SemanticBlockProto

// optional int32 voxels_per_side = 1;
inline bool SemanticMapProto_SemanticBlockProto::has_voxels_per_side() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SemanticMapProto_SemanticBlockProto::set_has_voxels_per_side() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SemanticMapProto_SemanticBlockProto::clear_has_voxels_per_side() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SemanticMapProto_SemanticBlockProto::clear_voxels_per_side() {
  voxels_per_side_ = 0;
  clear_has_voxels_per_side();
}
inline ::google::protobuf::int32 SemanticMapProto_SemanticBlockProto::voxels_per_side() const {
  // @@protoc_insertion_point(field_get:kimera.SemanticMapProto.SemanticBlockProto.voxels_per_side)
  return voxels_per_side_;
}
inline void SemanticMapProto_SemanticBlockProto::set_voxels_per_side(::google::protobuf::int32 value) {
  set_has_voxels_per_side();
  voxels_per_side_ = value;
  // @@protoc_insertion_point(field_set:kimera.SemanticMapProto.SemanticBlockProto.voxels_per_side)
}

// optional double voxel_size = 2;
inline bool SemanticMapProto_SemanticBlockProto::has_voxel_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SemanticMapProto_SemanticBlockProto::set_has_voxel_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SemanticMapProto_SemanticBlockProto::clear_has_voxel_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SemanticMapProto_SemanticBlockProto::clear_voxel_size() {
  voxel_size_ = 0;
  clear_has_voxel_size();
}
inline double SemanticMapProto_SemanticBlockProto::voxel_size() const {
  // @@protoc_insertion_point(field_get:kimera.SemanticMapProto.SemanticBlockProto.voxel_size)
  return voxel_size_;
}
inline void SemanticMapProto_SemanticBlockProto::set_voxel_size(double value) {
  set_has_voxel_size();
  voxel_size_ = value;
  // @@protoc_insertion_point(field_set:kimera.SemanticMapProto.SemanticBlockProto.voxel_size)
}

// optional .kimera.SemanticMapProto.SemanticBlockProto.OriginProto origin = 3;
inline bool SemanticMapProto_SemanticBlockProto::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SemanticMapProto_SemanticBlockProto::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SemanticMapProto_SemanticBlockProto::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SemanticMapProto_SemanticBlockProto::clear_origin() {
  if (origin_ != NULL) origin_->Clear();
  clear_has_origin();
}
inline const ::kimera::SemanticMapProto_SemanticBlockProto_OriginProto& SemanticMapProto_SemanticBlockProto::_internal_origin() const {
  return *origin_;
}
inline const ::kimera::SemanticMapProto_SemanticBlockProto_OriginProto& SemanticMapProto_SemanticBlockProto::origin() const {
  const ::kimera::SemanticMapProto_SemanticBlockProto_OriginProto* p = origin_;
  // @@protoc_insertion_point(field_get:kimera.SemanticMapProto.SemanticBlockProto.origin)
  return p != NULL ? *p : *reinterpret_cast<const ::kimera::SemanticMapProto_SemanticBlockProto_OriginProto*>(
      &::kimera::_SemanticMapProto_SemanticBlockProto_OriginProto_default_instance_);
}
inline ::kimera::SemanticMapProto_SemanticBlockProto_OriginProto* SemanticMapProto_SemanticBlockProto::release_origin() {
  // @@protoc_insertion_point(field_release:kimera.SemanticMapProto.SemanticBlockProto.origin)
  clear_has_origin();
  ::kimera::SemanticMapProto_SemanticBlockProto_OriginProto* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline ::kimera::SemanticMapProto_SemanticBlockProto_OriginProto* SemanticMapProto_SemanticBlockProto::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    auto* p = CreateMaybeMessage<::kimera::SemanticMapProto_SemanticBlockProto_OriginProto>(GetArenaNoVirtual());
    origin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kimera.SemanticMapProto.SemanticBlockProto.origin)
  return origin_;
}
inline void SemanticMapProto_SemanticBlockProto::set_allocated_origin(::kimera::SemanticMapProto_SemanticBlockProto_OriginProto* origin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete origin_;
  }
  if (origin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      origin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    set_has_origin();
  } else {
    clear_has_origin();
  }
  origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:kimera.SemanticMapProto.SemanticBlockProto.origin)
}

// repeated .kimera.SemanticMapProto.SemanticBlockProto.SemanticVoxelProto semantic_voxels = 4;
inline int SemanticMapProto_SemanticBlockProto::semantic_voxels_size() const {
  return semantic_voxels_.size();
}
inline void SemanticMapProto_SemanticBlockProto::clear_semantic_voxels() {
  semantic_voxels_.Clear();
}
inline ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto* SemanticMapProto_SemanticBlockProto::mutable_semantic_voxels(int index) {
  // @@protoc_insertion_point(field_mutable:kimera.SemanticMapProto.SemanticBlockProto.semantic_voxels)
  return semantic_voxels_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto >*
SemanticMapProto_SemanticBlockProto::mutable_semantic_voxels() {
  // @@protoc_insertion_point(field_mutable_list:kimera.SemanticMapProto.SemanticBlockProto.semantic_voxels)
  return &semantic_voxels_;
}
inline const ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto& SemanticMapProto_SemanticBlockProto::semantic_voxels(int index) const {
  // @@protoc_insertion_point(field_get:kimera.SemanticMapProto.SemanticBlockProto.semantic_voxels)
  return semantic_voxels_.Get(index);
}
inline ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto* SemanticMapProto_SemanticBlockProto::add_semantic_voxels() {
  // @@protoc_insertion_point(field_add:kimera.SemanticMapProto.SemanticBlockProto.semantic_voxels)
  return semantic_voxels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kimera::SemanticMapProto_SemanticBlockProto_SemanticVoxelProto >&
SemanticMapProto_SemanticBlockProto::semantic_voxels() const {
  // @@protoc_insertion_point(field_list:kimera.SemanticMapProto.SemanticBlockProto.semantic_voxels)
  return semantic_voxels_;
}

// -------------------------------------------------------------------

// SemanticMapProto

// repeated .kimera.SemanticMapProto.SemanticBlockProto semantic_blocks = 1;
inline int SemanticMapProto::semantic_blocks_size() const {
  return semantic_blocks_.size();
}
inline void SemanticMapProto::clear_semantic_blocks() {
  semantic_blocks_.Clear();
}
inline ::kimera::SemanticMapProto_SemanticBlockProto* SemanticMapProto::mutable_semantic_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:kimera.SemanticMapProto.semantic_blocks)
  return semantic_blocks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kimera::SemanticMapProto_SemanticBlockProto >*
SemanticMapProto::mutable_semantic_blocks() {
  // @@protoc_insertion_point(field_mutable_list:kimera.SemanticMapProto.semantic_blocks)
  return &semantic_blocks_;
}
inline const ::kimera::SemanticMapProto_SemanticBlockProto& SemanticMapProto::semantic_blocks(int index) const {
  // @@protoc_insertion_point(field_get:kimera.SemanticMapProto.semantic_blocks)
  return semantic_blocks_.Get(index);
}
inline ::kimera::SemanticMapProto_SemanticBlockProto* SemanticMapProto::add_semantic_blocks() {
  // @@protoc_insertion_point(field_add:kimera.SemanticMapProto.semantic_blocks)
  return semantic_blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kimera::SemanticMapProto_SemanticBlockProto >&
SemanticMapProto::semantic_blocks() const {
  // @@protoc_insertion_point(field_list:kimera.SemanticMapProto.semantic_blocks)
  return semantic_blocks_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace kimera

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_semantic_5fmap_2eproto
